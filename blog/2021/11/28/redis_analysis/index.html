<!doctype html><html lang=en-us class=h-100><head><meta charset=utf-8><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta name=viewport content="width=device-width,initial-scale=1"><title>A prelude to analysis of Redis memory-store</title><meta name=author content="Dragonfly"><meta name=keywords content="dragonfly,in-memory,datastore,scale,memory store"><meta name=description content="Will Redis stay competitive in a few years without reinventing itself?"><meta name=generator content="Hugo 0.101.0"><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3 crossorigin=anonymous><link rel=preload href=/scss/main.min.d6a921113015a1230f48d3c16ba0a7c0c7767e071ab339536b4918de4918a65f.css as=style><link href=/scss/main.min.d6a921113015a1230f48d3c16ba0a7c0c7767e071ab339536b4918de4918a65f.css rel=stylesheet integrity><link href='//fonts.googleapis.com/css?family=Poppins:600,700,800,900' rel=stylesheet type=text/css><link href='//fonts.googleapis.com/css?family=Lato:100,300,400' rel=stylesheet type=text/css><link rel="shortcut icon" href=/img/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/img/apple-touch-icon.png><meta property="og:locale" content="en_us"><meta property="og:site_name" content="Dragonfly"><meta property="og:title" content="A prelude to analysis of Redis memory-store"><meta property="og:type" content="article"><meta property="og:url" content="https://www.dragonflydb.io/blog/2021/11/28/redis_analysis/"><meta property="og:description" content="Will Redis stay competitive in a few years without reinventing itself?"><meta property="og:image" content="https://www.dragonflydb.io/img/banners/1200px-Redis_Logo.svg.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="401"><meta property="og:updated_time" content="2021-11-28T17:46:19+0300"><meta property="article:section" content="Engineering"><meta property="article:published_time" content="2021-11-28T17:46:19+0300"><meta property="article:modified_time" content="2021-11-28T17:46:19+0300"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@dragonflydbio"><meta name=twitter:title content="A prelude to analysis of Redis memory-store"><meta name=twitter:image content="https://www.dragonflydb.io/img/banners/1200px-Redis_Logo.svg.png"><meta name=twitter:description content="Will Redis stay competitive in a few years without reinventing itself?"><meta name=twitter:creator content="@romanger"><script src=https://cdn.lr-in-prod.com/LogRocket.min.js crossorigin=anonymous></script>
<script>window.LogRocket&&window.LogRocket.init("qy8vmk/dragonfly-website")</script></head><body class="d-flex flex-column h-100"><div class=flex-shrink-0><nav class="navbar navbar-expand-md navbar-light shadow-sm main-nav"><div class=container-lg><a class=navbar-brand href=/><img src=/img/logo.svg alt="A prelude to analysis of Redis memory-store logo" class=my-auto></a>
<button class="navbar-toggler collapsed" type=button data-bs-toggle=collapse data-bs-target=.navbar-collapse aria-controls=navbarNavAltMarkup aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse justify-content-end"><div class=navbar-nav><a class="nav-link active" zgotmplz href=/blog/>Blog</a>
<a class=nav-link zgotmplz href=/careers/>Careers</a>
<a class="nav-link git-icon" zgotmplz href=https://github.com/dragonflydb/dragonfly>Git</a>
<a target=_blank href=https://github.com/dragonflydb/dragonfly/blob/main/docs/quick-start/README.md class="btn btn-primary btn-get-started">Get Dragonfly</a></div></div></div></nav><main class=mx-auto style=max-width:2000px><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><div id=blog-post class=pt-5><div class=container><div class="row blog_header"><div class="col-2 d-none d-lg-flex"><a id=backBtn href=javascript:history.back(); class="btn btn-outline-dark my-auto">&lt; Back</a></div><div class=col><span class=category_label>Engineering</span><h1>A prelude to analysis of Redis memory-store</h1><h6 class="card-subtitle mb-2">November 28, 2021
By <a href=/authors/roman-gershman>Roman Gershman</a></h6></div><div class="col-2 d-none d-lg-flex"></div></div><div class=row><div class="col-2 d-none d-lg-flex"></div><div class=col><div id=post-content><p>During the last 13 years, Redis has become a truly ubiquitous memory store that has won the hearts
of numerous dev-ops and software engineers. Indeed, according to <a href=https://insights.stackoverflow.com/survey/2021#databases>StackOverflow survey in
2021</a>, Redis is the most loved database for the 5th time in a row and is at the top of
<a href=https://db-engines.com/en/ranking/key-value+store>db-engines</a> ranking, way before the next contestant.
But how well does Redis utilizes modern hardware systems?
Will it stay competitive in a few years without reinventing itself?</p><p>To understand choices behind Redis design, I have been reading <a href=http://oldblog.antirez.com/>the old posts</a> of Salvatore @antirez - the creator of Redis. Before I begin, I want to add that I have tremendous respect for Salvatore and for how much he achieved by being a talented and authentic software programmer
(even though <a href=http://antirez.com/news/133>he does not want to be remembered as such</a>).</p><p>Based on his notes and GitHub discussions, I identified the following architectural principles in Redis:</p><ol><li><p><strong>Simple is beautiful (and code is a poem)</strong><br>Probably the strongest motive around Redis is simplicity. Salvatore&rsquo;s preference is towards simple solutions and he expressed his attitude to coding in his
<a href=http://oldblog.antirez.com/post/redis-manifesto.html>Redis manifesto</a>. As a consequence,
Redis resides in a single self-contained codebase without much reliance on third-party projects and
its functionality is implemented in plain C using posix API.</p></li><li><p><strong>Single-threaded architecture</strong><br>Redis development started a few years after Memcached. By that time, Memcached, the predecessor of Redis,
has already been a mature system that has been used and supported by large, highly
technological companies like Facebook and Twitter. It used multi-threaded architecture
to scale its I/O performance vertically within a single node.
Remarkably, antirez decided against this architecture and adopted the single-threaded design instead.
Specifically, Redis utilizes a single thread that manipulates its
main in-memory dictionary. antirez has defended this approach many times with the following arguments:</p><ul><li>Redis cares very much about latency and adopts share-nothing architecture to control its tail
and average latencies.</li><li>Most of the CPU spent on system-cpu handling I/O and not on userland cpu handling Redis data-structures.
Therefore, the upside of parallelization is limited anyway.</li><li>Pipelining of requests can increase throughput by order of magnitude.</li><li>On the other hand, multi-threading adds complexity. Quoting antirez:
&ldquo;&mldr;Slower development speed to achieve the same features. Multi-thread programming is hard&mldr;
In a future of cloud computing, I want to consider every single core as a computer itself&mldr;&rdquo;</li><li>Vertical scale has physical limit anyway, therefore horizontal scaling (aka Redis cluster)
is the way to scale.</li></ul></li></ol><p>In addition to the principles above, Redis maintains unique design goals that differentiate it
from, say, a disk-based database. I believe that if we list Redis design goals by priority, it will be:</p><ol><li>Low latency</li><li>High throughput</li><li>Memory efficiency</li><li>High availability</li><li>Strong consistency guarantees</li><li>Durability</li></ol><p>Obviously, if one would want to implement an alternative memory store he would need to prioritize design goals
similarly to Redis. In other words, the new store design should not sacrifice low latency for durability,
or for strong consistency.</p><h2 id=retrospective>Retrospective</h2><p>I think that <em>simplicity</em> was the main guideline for Redis which heavily affected architectural decisions
like its serialization algorithm, efficiency of its data structures, reliability and more.
Even the choice of its threading model has been, in part, done because of simplicity reasons.
And if Redis is the experiment on how far one can go nowdays by implementing relatively simple solutions, it without
a question succeeded tremendously.</p><p>Redis in 2021 is a mature product with relatively stable feature set, and the questions I am asking myself
today are:
a) how more efficienty Redis could be today if it would adopt state-of-the-art algorithms and datastructures.
b) how much simpler it would be for a user if it adopt product simplicity over simplicity of implementation.</p><p>In other words, if one would want to implement a drop-in replacement for Redis <strong>today</strong> by
redesigning it from scratch, how it would compare to Redis. I do not have a definite answer to this question today but hope to have one in few months.</p><p>Again, I am not arguing with the tremendous popularity of the Redis memory store. It seems that Salvatore&rsquo;s
decision to go for simplicity and deliver features quickly in Redis early days - paid off: today Memcached is a niche
system, and the vast majority of software stacks use Redis. However, I do claim (currently without proof)
that it is possible to <strong>vastly</strong> improve reliability, performance and cost-efficiency metrics of Redis-like memory store that follows similar design goals but with different architectural principles.</p><p>In my next posts, I am going to detail Redis specific design choices based on the principles state above
and show how a different architecture, if aligned better with modern hardware systems, could provide, what I think
a disruptive change to in-memory datastores.</p></div></div><div class="col-2 d-none d-lg-flex"></div></div></div></div><script>console.log(document.referrer),(!document.referrer||!document.referrer.toLowerCase().includes("dragonlfydb.io")&&!document.referrer.toLowerCase().includes("localhost"))&&(document.getElementById("backBtn").style.display="none")</script></main></div><footer id=copyright class="footer mt-auto py-3"><div class=container><div class=row><div class=col-12><img src=/img/icon.svg></div></div><div class=row><div class=col-6><p><a href=https://twitter.com/dragonflydbio rel=author><i class="fa-brands fa-twitter"></i></a>
<a href=mailto:info@dragonflydb.io><i class="fa-solid fa-at"></i></a>
<a href=https://github.com/dragonflydb/dragonfly><i class="fa-brands fa-github"></i></a></p><p><a href=/privacy/>Privacy Policy</a></p><p>Copyright (c) 2022, Attos Technologies Ltd; all rights reserved.</p></div><div class=col-6><small>* Redis is a trademark of Redis Ltd. Any rights therein are reserved to Redis Ltd. Any use by Attos is for referential purposes only and does not indicate any sponsorship, endorsement or affiliation between Redis and Attos.</small></div></div></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-EZMGVEP6RT"></script>
<script>var dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EZMGVEP6RT",{anonymize_ip:!1})}</script><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js integrity=sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p crossorigin=anonymous></script>
<script>var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)})</script></body></html>