<!doctype html><html lang=en-us class=h-100><head><meta charset=utf-8><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta name=viewport content="width=device-width,initial-scale=1"><title>Balanced vs Unbalanced</title><meta name=author content="Dragonfly"><meta name=keywords content="dragonfly,in-memory,datastore,scale,memory store"><meta name=description content="Why Dragonfly is winning the hearts of developers&amp;hellip;"><meta name=generator content="Hugo 0.105.0"><link href=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3 crossorigin=anonymous><link rel=preload href=/scss/main.min.3d347c1affa06e5e5350468422e025983cb0450a7db3aa906adc44b7ea1ed797.css as=style><link href=/scss/main.min.3d347c1affa06e5e5350468422e025983cb0450a7db3aa906adc44b7ea1ed797.css rel=stylesheet integrity><link href='//fonts.googleapis.com/css?family=Poppins:600,700,800,900' rel=stylesheet type=text/css><link href='//fonts.googleapis.com/css?family=Lato:100,300,400' rel=stylesheet type=text/css><link rel="shortcut icon" href=/img/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/img/apple-touch-icon.png><meta property="og:updated_time" content="2022-10-30T12:00:00+0300"><meta property="article:section" content="Engineering"><meta property="article:published_time" content="2022-10-30T12:00:00+0300"><meta property="article:modified_time" content="2022-10-30T12:00:00+0300"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@dragonflydbio"><meta name=twitter:title content="Balanced vs Unbalanced"><meta name=twitter:image content="https://www.dragonflydb.io/blog/snapshot/img/floaty-jerry.png"><meta name=twitter:description content="Why Dragonfly is winning the hearts of developers&amp;hellip;"><script src=https://cdn.lr-in-prod.com/LogRocket.min.js crossorigin=anonymous></script>
<script>window.LogRocket&&window.LogRocket.init("qy8vmk/dragonfly-website")</script></head><body class="d-flex flex-column h-100"><div class=flex-shrink-0><nav class="navbar navbar-expand-md navbar-light shadow-sm main-nav"><div class=container-lg><a class=navbar-brand href=/><img src=/img/logo.svg alt="Balanced vs Unbalanced logo" class=my-auto></a>
<button class="navbar-toggler collapsed" type=button data-bs-toggle=collapse data-bs-target=.navbar-collapse aria-controls=navbarNavAltMarkup aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse justify-content-end"><div class=navbar-nav><a class=nav-link zgotmplz href=/platform/>Platform</a>
<a class=nav-link zgotmplz href=/docs/>Docs</a>
<a class="nav-link active" zgotmplz href=/blog/>Blog</a>
<a class=nav-link zgotmplz href=/careers/>Careers</a>
<a class="nav-link git-icon" zgotmplz href=https://github.com/dragonflydb/dragonfly>Git</a>
<a class="nav-link discord-icon" zgotmplz href=https://discord.gg/HsPjXGVH85>Discord</a>
<a target=_blank href=https://github.com/dragonflydb/dragonfly/blob/main/docs/quick-start/README.md class="btn btn-primary btn-get-started">Get Dragonfly</a></div></div></div></nav><main class=mx-auto style=max-width:2000px><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><div id=blog-post class=pt-5><div class=container><div class="row blog_header"><div class="col-2 d-none d-lg-flex"><a id=backBtn href=javascript:history.back(); class="btn btn-outline-dark my-auto">&lt; Back</a></div><div class=col><span class=category_label>Engineering</span><h1>Balanced vs Unbalanced</h1><h6 class="card-subtitle mb-2">October 30, 2022
By <a href=/authors/roman-gershman>Roman Gershman</a></h6></div><div class="col-2 d-none d-lg-flex"></div></div><div class=row><div class="col-2 d-none d-lg-flex"></div><div class=col><div id=post-content><p>Or why Dragonfly is winning hearts of developers&mldr;</p><figure><img src=img/floaty-jerry.png></figure><p>Balance is essential in life. When our focus is limited to improving a single aspect of our life, we weaken the whole system. And if you don&rsquo;t provide stability for your system, it will eventually collapse under its own weight and break (or, in the case of Jerry - float).</p><p>Take Redis, for example. It supports a relatively high throughput, but its persistency mechanism is not designed to support high loads: the higher the write throughput in Redis, the more fragile the system becomes. To understand why, I need to explain how Redis BGSAVE snapshotting works.</p><p>The BGSAVE algorithm allows Redis to produce a point-in-time snapshot of its in-memory data to the disk, or sync with its secondary replica, as a background process.
Redis does this by calling Linux &ldquo;fork()&rdquo; to open a child process that can access the parent’s memory. From this point onward, both processes have the same contents, and their physical memory usage stays the same, but as soon as one of them writes into memory, it creates a private copy of the page.</p><figure><img src=img/fork-memory.svg></figure><p>This feature is called Copy-on-Write, and it&rsquo;s part of Linux&rsquo;s memory management system. The moment a memory page is duplicated by one of the processes, Linux must allocate an additional 4Kb of physical memory.</p><p>The Redis child process does not alter its memory pages—it only scans the entries and writes them into an RDB snapshot. Meanwhile, the parent Redis process continues handling incoming writes. With each write that touches an existing memory page, it effectively allocates more physical memory. Suppose our Redis instance uses 40GB of physical memory. After the fork(), the parent process can potentially duplicate each page, requiring an additional 40GB of RAM: 80GB in total.</p><p>But if Redis&rsquo;s write throughput is low enough, it might finish the snapshot process before it duplicates all the pages. In this case, it may end up peaking somewhere between 40GB and 80GB. This uncertain behavior during BGSAVE causes huge headaches to the teams that manage Redis deployments: they need to mitigate the risk of OOM with memory over-provisioning.</p><p>KeyDB, a Redis fork that was released with a promise of making Redis faster, can sustain higher throughput due to its multi-threaded architecture. But what happens when BGSAVE is triggered in KeyDB? The KeyDB parent process can handle more write traffic, so it alters more memory pages shared with the child process before BGSAVE finishes. As a result, physical memory usage increases, putting the whole system at greater risk.</p><p>Is this KeyDB&rsquo;s fault? No, because KeyDB is not more memory hungry, and its BGSAVE algorithm is the same as that of Redis. But, unfortunately, by solving one problem within the unbalanced architecture of Redis, it introduces others.</p><p>This narrow approach is not unique to KeyDB. AWS ElastiCache introduced a similar, closed-source feature that <a href=https://aws.amazon.com/blogs/database/boosting-application-performance-and-reducing-costs-with-amazon-elasticache-for-redis/>increases the throughput</a> of its Redis instances on multi-CPU machines. Based on my tests, it suffers from the same problem: under a high throughput scenario, it either fails to produce a snapshot or reduces the throughput to ridiculous rates of less than 15K qps.</p><h2 id=dragonfly-snapshotting>Dragonfly snapshotting</h2><p>Let&rsquo;s take a step back and formalize the problem. The main challenge of performing point-in-time snapshotting is preserving the snapshot isolation property
when records are altered in parallel: if a snapshot starts at time <code>t</code> and ends at <code>t+u</code>,
it should reflect the state of all entries as they were at time <code>t</code>.</p><p>Therefore, we need a scheme for handling records that must be modified due to incoming updates, but have not yet been serialized. And this leads us to the question: how do we even recognize which entries in our snapshotting routine have already been serialized and which haven&rsquo;t?</p><p>Dragonfly uses <em>versioning</em> for that. It maintains a monotonically increasing counter that
increases with every update. Each dictionary entry in the store captures its “last update” version,
which is then used to determine whether the entry should be serialized. When snapshotting starts, it assigns the next version to itself, thus preserving the following variant for all entries in the store: <code>entry.version &lt; snapshot.version</code>.</p><p>Then it kicks off the main traversal loop that iterates over the dictionary and starts serializing it to disk. This is done asynchronously, as shown conceptually below with the <code>fiber_yield()</code> call.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">199
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">200
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">201
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">202
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">203
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">204
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">205
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">206
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">207
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">208
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>snapshot.version <span style=color:#f92672>=</span> next_version<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (entry : table) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (entry.version <span style=color:#f92672>&lt;</span> snapshot.version) {
</span></span><span style=display:flex><span>     entry.version <span style=color:#f92672>=</span> snapshot.version;
</span></span><span style=display:flex><span>     SendToSerializationSink(entry);
</span></span><span style=display:flex><span>     fiber_yield();
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>The loop is not atomic, and Dragonfly can accept incoming writes in parallel. Each of these write requests can modify, delete or add entries to the dictionary. By checking the entry version in the traversal loop, we ensure that no entry is serialized twice, or that the entries that have been modified after the snapshotting started are not serialized.</p><p>The loop above is only part of the solution. We also need to handle updates happening in parallel:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">299
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">300
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">301
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">302
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">303
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">304
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">305
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">306
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">307
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">308
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">309
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>OnPreUpdate</span>(entry) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> old_version <span style=color:#f92672>=</span> entry.version;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Update the version to the newest one.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  entry.version <span style=color:#f92672>=</span> next_version<span style=color:#f92672>++</span>;  <span style=color:#75715e>// Regular version update
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (snapshot.active <span style=color:#f92672>&amp;&amp;</span> old_version <span style=color:#f92672>&lt;</span> snapshot.version) {
</span></span><span style=display:flex><span>    SendToSerializationSink(entry);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>We make sure that entries that have not been serialized yet (have <code>version</code> smaller than <code>snapshot.version</code>) will be serialized before they are updated.</p><p>Both the main traversal loop and the <code>OnPreUpdate</code> hook are enough to make sure that we serialize each existing entry exactly once and entries that are added after the snapshot has started won&rsquo;t be serialized at all. Dragonfly does not rely on OS generic memory management.</p><p>By avoiding an unbalanced <code>fork()</code> call and by pushing entries to the serialization sink during the update, Dragonfly establishes a natural back-pressure mechanism, which is a must have for every reliable system. As a result of all these factors, Dragonfly&rsquo;s memory overhead is constant during the snapshotting no matter how big the dataset size is.</p><p>Is it really this simple? Not quite. While the high-level algorithm as described above is accurate, I have not shown how we coordinate snapshotting across multiple threads,
or how we maintain the <code>uint64_t</code> “version” per entry without wasting 8 bytes on each key, etc.</p><p>While the snapshotting issue may not seem very significant at first glance, it&rsquo;s actually a cornerstone of the balanced foundation that makes Dragonfly a reliable, performant and scalable system. A feature like snapshotting is one of those things that differentiate Dragonfly from other attempts to build a high-performing memory store, and I think the developer community recognizes this.</p><figure><img src=img/starthist-keydb-df.png></figure></div></div><div class="col-2 d-none d-lg-flex"></div></div></div></div><script>console.log(document.referrer),(!document.referrer||!document.referrer.toLowerCase().includes("dragonflydb.io")&&!document.referrer.toLowerCase().includes("localhost"))&&(document.getElementById("backBtn").style.display="none")</script></main></div><footer id=copyright class="footer mt-auto py-3"><div class=container><div class=row><div class=col-12><img src=/img/icon.svg></div></div><div class=row><div class=col-6><p><a href=https://twitter.com/dragonflydbio rel=author><i class="fa-brands fa-twitter"></i></a>
<a href=mailto:info@dragonflydb.io><i class="fa-solid fa-at"></i></a>
<a href=https://github.com/dragonflydb/dragonfly><i class="fa-brands fa-github"></i></a></p><p><a href=/privacy/>Privacy Policy</a>
<a class=mx-2 href=/terms/>Terms of Use</a></p><p>Copyright (c) 2022, Attos Technologies Ltd; all rights reserved.</p></div><div class=col-6><small>* Redis is a trademark of Redis Ltd. Any rights therein are reserved to Redis Ltd. Any use by Attos is for referential purposes only and does not indicate any sponsorship, endorsement or affiliation between Redis and Attos.</small></div></div></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-EZMGVEP6RT"></script>
<script>var dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EZMGVEP6RT",{anonymize_ip:!1})}</script><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js integrity=sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p crossorigin=anonymous></script>
<script>var tooltipTriggerList=[].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')),tooltipList=tooltipTriggerList.map(function(e){return new bootstrap.Tooltip(e)}),toastElList=[].slice.call(document.querySelectorAll(".toast")),toastList=toastElList.map(function(e){return new bootstrap.Toast(e,{})})</script></body></html>